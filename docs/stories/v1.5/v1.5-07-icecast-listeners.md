# Story V1.5-07: Implementar Query de Listeners do Icecast

**Epic:** V1.5 - Hardening & Quality (Post-Audit)

**Status:** done

**Prioridade:** üü° Alto

**Origem:** Relat√≥rio de Auditoria 2025-12-03 - Se√ß√£o 5: Audio Pipeline (8/10)

**User Story:**
Como usu√°rio,
quero ver quantos ouvintes est√£o conectados ao stream,
para que eu saiba se outras pessoas est√£o escutando.

## Contexto do Problema

Atualmente o contador de listeners n√£o est√° implementado:

```typescript
// audio-manager.ts:468
listeners: undefined, // TODO: Implementar query ao Icecast2 stats
```

O Icecast2 fornece um endpoint de estat√≠sticas que pode ser consultado para obter essa informa√ß√£o.

## Crit√©rios de Aceita√ß√£o

1. [x] Fun√ß√£o para query do Icecast2 stats endpoint implementada
2. [x] Contador de listeners dispon√≠vel via API (`GET /api/status`)
3. [x] Contador atualizado periodicamente (cache de 5 segundos)
4. [x] Frontend exibe n√∫mero de listeners no card de Streaming do Dashboard
5. [x] Tratamento de erro quando Icecast n√£o est√° acess√≠vel (retorna cache ou 0)
6. [x] Cache local para evitar queries excessivas (TTL de 5s)

## Pr√©-requisitos

- Icecast2 configurado e funcionando (V1.3)

## Refer√™ncias

- [Relat√≥rio de Auditoria](../../audit-report-2025-12-03.md) - Se√ß√£o 5: Audio Pipeline
- [Icecast2 Statistics](https://icecast.org/docs/icecast-trunk/server_stats.html)

---

## Tasks/Subtasks

- [x] Task 1: Criar servi√ßo de query do Icecast
  - [x] Criar `backend/src/services/icecast-stats.ts`
  - [x] Implementar parse do JSON de stats (`/status-json.xsl`)
  - [x] Cache com TTL de 5 segundos
  - [x] Timeout de 3 segundos para n√£o bloquear

- [x] Task 2: Integrar com AudioManager
  - [x] Adicionar m√©todo `getStreamingStatusWithListeners()` async
  - [x] Manter `getStreamingStatus()` s√≠ncrono para compatibilidade
  - [x] Import do `getListenerCount()` do icecast-stats

- [x] Task 3: Expor via API
  - [x] Atualizar `GET /api/status` para usar m√©todo async
  - [x] Listeners inclu√≠do na resposta da API
  - [~] Emitir via WebSocket ‚Äî **N/A: WebSocket j√° recebe status completo**

- [x] Task 4: Atualizar Frontend
  - [x] Exibir contador no card de Streaming do Dashboard
  - [x] √çcone de headphones + texto "X ouvinte(s)"
  - [~] Exibir no player ‚Äî **N/A: N√£o h√° player separado**

- [x] Task 5: Testes (9 testes)
  - [x] Mock do endpoint Icecast para testes
  - [x] Teste de cache
  - [x] Teste de fallback quando Icecast offline
  - [x] Teste de array de sources
  - [x] Teste de clearCache

---

## Implementa√ß√£o Sugerida

```typescript
// backend/src/services/icecast-stats.ts
import { createLogger } from '../utils/logger';

const logger = createLogger('IcecastStats');

interface IcecastStats {
  listeners: number;
  source: string;
  bitrate: number;
  serverName: string;
}

let cachedStats: IcecastStats | null = null;
let lastFetch = 0;
const CACHE_TTL_MS = 5000; // 5 segundos

export async function getIcecastStats(): Promise<IcecastStats | null> {
  const now = Date.now();
  
  // Retornar cache se ainda v√°lido
  if (cachedStats && (now - lastFetch) < CACHE_TTL_MS) {
    return cachedStats;
  }
  
  try {
    const icecastHost = process.env.ICECAST_HOST || 'localhost';
    const icecastPort = process.env.ICECAST_PORT || '8000';
    const url = `http://${icecastHost}:${icecastPort}/status-json.xsl`;
    
    const response = await fetch(url, { 
      signal: AbortSignal.timeout(3000) 
    });
    
    if (!response.ok) {
      throw new Error(`Icecast stats returned ${response.status}`);
    }
    
    const data = await response.json();
    const source = data.icestats?.source;
    
    // Icecast pode retornar source como array ou objeto
    const sourceData = Array.isArray(source) ? source[0] : source;
    
    cachedStats = {
      listeners: sourceData?.listeners || 0,
      source: sourceData?.server_name || '/stream',
      bitrate: sourceData?.bitrate || 128,
      serverName: data.icestats?.host || 'Vinyl-OS'
    };
    
    lastFetch = now;
    return cachedStats;
    
  } catch (error) {
    logger.warn('Falha ao obter stats do Icecast', { error });
    return cachedStats; // Retorna cache antigo se dispon√≠vel
  }
}

export async function getListenerCount(): Promise<number> {
  const stats = await getIcecastStats();
  return stats?.listeners ?? 0;
}
```

### Integra√ß√£o com AudioManager

```typescript
// backend/src/services/audio-manager.ts
import { getListenerCount } from './icecast-stats';

async getStatus(): Promise<AudioStatus> {
  return {
    isStreaming: this.isStreaming,
    device: this.audioDevice,
    sampleRate: this.sampleRate,
    channels: this.channels,
    listeners: await getListenerCount(), // ‚Üê Implementado
    // ...
  };
}
```

---

## Dev Agent Record

### Context Reference
- Story Context: [v1.5-07-icecast-listeners.context.xml](./v1.5-07-icecast-listeners.context.xml)

### Debug Log
- 2025-12-03: Criado servi√ßo icecast-stats.ts com cache de 5s
- 2025-12-03: Integrado com audio-manager.ts (m√©todo async)
- 2025-12-03: Atualizado Dashboard.tsx com √≠cone de headphones
- 2025-12-03: 9 testes criados e passando

### Completion Notes
- **Backend:** Novo servi√ßo `icecast-stats.ts` consulta `/status-json.xsl` do Icecast
- **Cache:** TTL de 5 segundos para evitar sobrecarga no Icecast
- **Timeout:** 3 segundos para n√£o bloquear a API se Icecast estiver lento
- **Frontend:** Card de Streaming agora mostra "üéß X ouvinte(s)"
- **Testes:** 9 testes cobrindo sucesso, cache, erros e edge cases
- **Compatibilidade:** M√©todo s√≠ncrono `getStreamingStatus()` mantido para c√≥digo existente

---

## File List

### Arquivos a Criar
- backend/src/services/icecast-stats.ts
- backend/src/__tests__/services/icecast-stats.test.ts

### Arquivos a Modificar
- backend/src/services/audio-manager.ts
- backend/src/routes/status.ts
- frontend/src/components/Player.tsx (ou equivalente)
- frontend/src/pages/Dashboard.tsx

---

## Change Log

- 2025-12-04: Story criada a partir do relat√≥rio de auditoria
- 2025-12-03: Story implementada e marcada como done

