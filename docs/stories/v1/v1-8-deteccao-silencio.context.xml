<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>V1</epicId>
    <storyId>8</storyId>
    <title>Detecção de Silêncio</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-03</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/v1/v1-08-deteccao-silencio.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Como usuário</asA>
    <iWant>quero que o sistema detecte quando não há áudio (silêncio)</iWant>
    <soThat>para que possa identificar quando o toca-discos está parado</soThat>
    <tasks>
      <task id="1">Serviço `event-detector.ts` analisa nível de áudio em tempo real</task>
      <task id="2">Threshold configurável (default: -50dB)</task>
      <task id="3">Duração configurável (default: 10s)</task>
      <task id="4">Evento `silence.detected` emitido via EventBus quando detectado</task>
      <task id="5">Evento `silence.ended` emitido quando áudio retorna</task>
      <task id="6">Status disponível via API</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Serviço `event-detector.ts` analisa nível de áudio em tempo real</criterion>
    <criterion id="2">Threshold configurável (default: -50dB)</criterion>
    <criterion id="3">Duração configurável (default: 10s)</criterion>
    <criterion id="4">Evento `silence.detected` emitido via EventBus quando detectado</criterion>
    <criterion id="5">Evento `silence.ended` emitido quando áudio retorna</criterion>
    <criterion id="6">Status disponível via API</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/prd-v3.md</path>
        <title>Product Requirements Document v3.0</title>
        <section>5.1.3 Reconhecimento Sonoro - Detecção de Silêncio</section>
        <snippet>Detecção de Silêncio: Threshold configurável (-50dB padrão), Duração configurável (10s padrão), Evento: silence.detected. Foco em eventos físicos do toca-discos para identificar quando está parado.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-v1.md</path>
        <title>Epic Technical Specification: Foundation Core (MVP)</title>
        <section>Workflow 2: Event Detection</section>
        <snippet>AudioManager monitora nível de áudio (FFmpeg metadata). EventDetector recebe audio level events via EventBus. EventDetector analisa thresholds: Silêncio: level &lt; threshold (-50dB) por duration (10s). EventDetector emite eventos via EventBus (silence.detected, etc.).</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-v1.md</path>
        <title>Epic Technical Specification: Foundation Core (MVP)</title>
        <section>APIs and Interfaces</section>
        <snippet>GET /api/status Response inclui audio: { level_db, clipping_detected, silence_detected }. Eventos EventBus: silence.detected, silence.ended. WebSocket Server → Client: { type: "audio_event", data: { event_type, timestamp, metadata } }.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epics - V1 Foundation Core</title>
        <section>Story V1.8: Detecção de Silêncio</section>
        <snippet>Como usuário, quero que o sistema detecte quando não há áudio (silêncio), para que possa identificar quando o toca-discos está parado. Critérios: Serviço event-detector.ts analisa nível de áudio em tempo real, Threshold configurável (default: -50dB), Duração configurável (default: 10s), Evento silence.detected emitido via EventBus, Evento silence.ended emitido quando áudio retorna, Status disponível via API.</snippet>
      </doc>
      <doc>
        <path>docs/stories/v1/v1-07-eventbus-core.md</path>
        <title>Story V1.7: EventBus Core</title>
        <section>Critérios de Aceitação</section>
        <snippet>Utilitário event-bus.ts criado com padrão publish/subscribe. Eventos suportados incluem silence.detected e silence.ended. Múltiplos listeners por evento. Payload serializável (objeto plano). Handlers async que não lançam exceções não tratadas.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>backend/src/services/event-detector.ts</path>
        <kind>service</kind>
        <symbol>EventDetector</symbol>
        <lines>N/A</lines>
        <reason>Serviço principal a ser criado. Analisa nível de áudio em tempo real, monitora thresholds configuráveis, e emite eventos silence.detected e silence.ended via EventBus.</reason>
      </artifact>
      <artifact>
        <path>backend/src/utils/event-bus.ts</path>
        <kind>utility</kind>
        <symbol>eventBus</symbol>
        <lines>N/A</lines>
        <reason>EventBus criado na story V1.7 (pré-requisito). EventDetector deve usar publish() para emitir eventos silence.detected e silence.ended. EventDetector deve usar subscribe() para receber audio level events.</reason>
      </artifact>
      <artifact>
        <path>backend/src/services/audio-manager.ts</path>
        <kind>service</kind>
        <symbol>AudioManager</symbol>
        <lines>488-498</lines>
        <reason>AudioManager possui método extractAudioLevel() preparado mas não implementado. Deve emitir eventos de nível de áudio via EventBus para que EventDetector possa analisar. Método extractAudioLevel() comentado sugere uso de FFmpeg metadata (volumedetect).</reason>
      </artifact>
      <artifact>
        <path>backend/src/routes/status.ts</path>
        <kind>route</kind>
        <symbol>createStatusRouter</symbol>
        <lines>N/A</lines>
        <reason>Rota GET /api/status deve incluir informação de silence_detected no response audio object conforme tech-spec. Status deve ser obtido de EventDetector.</reason>
      </artifact>
    </code>
    <dependencies>
      <ecosystem name="node">
        <package name="typescript" version="^5.9.3" />
        <package name="express" version="^4.21.2" />
        <package name="winston" version="^3.18.3" />
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>EventDetector deve ser criado como serviço em backend/src/services/event-detector.ts</constraint>
    <constraint>Pré-requisito: V1.7 - EventBus Core deve estar implementado (event-bus.ts disponível)</constraint>
    <constraint>EventDetector deve receber audio level events via EventBus (não diretamente de AudioManager)</constraint>
    <constraint>Threshold de silêncio: configurável, default -50dB</constraint>
    <constraint>Duração de silêncio: configurável, default 10s</constraint>
    <constraint>Eventos EventBus: silence.detected (quando silêncio detectado após duração), silence.ended (quando áudio retorna)</constraint>
    <constraint>Payload dos eventos deve ser objeto plano serializável: { timestamp: string, level_db?: number, duration?: number }</constraint>
    <constraint>Status de silêncio deve estar disponível via GET /api/status (campo audio.silence_detected)</constraint>
    <constraint>EventDetector deve funcionar em tempo real, analisando níveis de áudio continuamente</constraint>
    <constraint>Configurações (threshold, duração) devem ser armazenadas e carregadas de settings (futuro: via Prisma Settings, V1 pode usar variáveis de ambiente ou config file)</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>EventDetector Service</name>
      <kind>TypeScript Service</kind>
      <signature>
// backend/src/services/event-detector.ts

interface SilenceDetectionConfig {
  threshold: number;  // dB, default -50
  duration: number;   // seconds, default 10
}

class EventDetector {
  constructor(eventBus: EventBus, config?: Partial&lt;SilenceDetectionConfig&gt;);
  start(): void;
  stop(): void;
  getSilenceStatus(): boolean;
}
      </signature>
      <path>backend/src/services/event-detector.ts</path>
    </interface>
    <interface>
      <name>EventBus Events</name>
      <kind>Event Type</kind>
      <signature>
// Eventos publicados por EventDetector
'silence.detected': { timestamp: string, level_db: number, duration: number }
'silence.ended': { timestamp: string, level_db: number }

// Eventos recebidos por EventDetector (de AudioManager via EventBus)
'audio.level': { timestamp: string, level_db: number }
      </signature>
      <path>backend/src/services/event-detector.ts (usa EventBus)</path>
    </interface>
    <interface>
      <name>Status API Response</name>
      <kind>REST API</kind>
      <signature>
// GET /api/status
Response: {
  audio: {
    level_db: number,
    clipping_detected: boolean,
    silence_detected: boolean  // Novo campo adicionado nesta story
  },
  // ... outros campos
}
      </signature>
      <path>backend/src/routes/status.ts</path>
    </interface>
  </interfaces>
  <tests>
    <standards>Backend utiliza TypeScript e Jest para testes. Testes devem ser escritos em backend/src/__tests__/services/event-detector.test.ts. EventDetector deve ser testável isoladamente usando mocks do EventBus. Padrão de testes similar a audio-manager.test.ts existente.</standards>
    <locations>backend/src/__tests__/services/event-detector.test.ts. Testes de integração podem usar backend/src/__tests__/integration/ se necessário.</locations>
    <ideas>
      <test idea="1" criterion="1">Testar criação do serviço EventDetector: verificar que pode ser instanciado com EventBus e config opcional, verificar que valores default são aplicados (threshold -50dB, duration 10s), verificar que valores customizados são aplicados</test>
      <test idea="2" criterion="1">Testar análise de nível de áudio em tempo real: mockar EventBus, simular eventos audio.level com diferentes níveis, verificar que EventDetector processa eventos corretamente, verificar tracking de estado interno</test>
      <test idea="3" criterion="2">Testar threshold configurável: criar EventDetector com threshold customizado, enviar eventos com nível abaixo e acima do threshold, verificar comportamento correto</test>
      <test idea="4" criterion="3">Testar duração configurável: criar EventDetector com duração customizada, simular silêncio por períodos diferentes, verificar que evento silence.detected só é emitido após duração configurada</test>
      <test idea="5" criterion="4">Testar emissão de evento silence.detected: mockar EventBus, simular silêncio (level abaixo threshold por duração), verificar que silence.detected é publicado com payload correto { timestamp, level_db, duration }</test>
      <test idea="6" criterion="5">Testar emissão de evento silence.ended: mockar EventBus, simular silêncio seguido de áudio retornando, verificar que silence.ended é publicado com payload correto { timestamp, level_db }</test>
      <test idea="7" criterion="6">Testar status via API: criar instância EventDetector, simular detecção de silêncio, verificar que getSilenceStatus() retorna true, verificar integração com rota GET /api/status retorna silence_detected: true</test>
      <test idea="8">Testar edge cases: transições rápidas de silêncio/áudio, threshold exatamente no limite, múltiplas detecções sequenciais, eventos de áudio durante período de silêncio</test>
      <test idea="9">Testar integração com EventBus: verificar que EventDetector se inscreve em eventos audio.level corretamente, verificar que eventos são publicados corretamente, verificar que múltiplos listeners podem receber eventos</test>
    </ideas>
  </tests>
</story-context>

